## 总结

1. 根据node版本选择对应的渲染模块
2. 利用express起服务，支持自定义proxy，设置静态文件服务器，拦截请求，如果没有找到则返回index.html
3. 


## prerender

```js
// 步骤一：
{
  "name": "@prerenderer/prerenderer",
  "version": "0.7.2",
  "description": "Fast, flexible, framework-agnostic prerendering for sites and SPAs.",
  "license": "MIT",
  "main": "index.js", // 文件的主入口
  "scripts": {
    "build": "babel es6 --out-dir es5-autogenerated",
    "test": "jest ./test --silent --runInBand",
    "test:jsdom": "jest ./test/**/*.jsdom.test.js --silent --runInBand",
    "test:puppeteer": "jest ./test/**/*.puppeteer.test.js --silent --runInBand",
    "test:logs": "jest ./test --runInBand",
    "test:logs:jsdom": "jest ./test/**/*.jsdom.test.js --runInBand",
    "test:logs:puppeteer": "jest ./test/**/*.puppeteer.test.js --runInBand",
    "prepublishOnly": "npm run build"
  },
  "jest": {
    "transform": {},
    "testURL": "http://localhost/"
  },
  "files": [
    "es6/*",
    "es5-autogenerated/*"
  ],
  "keywords": [
    "prerender",
    "prerenderer",
    "spa",
    "ssr",
    "serverside-rendering",
    "chrome-rdp"
  ],
  "author": {
    "name": "Joshua Bemenderfer",
    "email": "tribex10@gmail.com",
    "url": "https://joshderf.com/"
  },
  "contributors": [
    {
      "name": "Joshua Bemenderfer",
      "email": "tribex10@gmail.com",
      "url": "https://joshderf.com/"
    }
  ],
  "repository": "Tribex/prerenderer",
  "bugs": {
    "url": "https://github.com/Tribex/prerenderer/issues",
    "email": "tribex10@gmail.com"
  },
  "dependencies": {
    "express": "^4.16.2", // express服务器
    "http-proxy-middleware": "^0.18.0", // 代理转发
    "portfinder": "^1.0.13" // 端口查找
  },
  "devDependencies": {
    "babel-cli": "^6.26.0",
    "babel-eslint": "^7.2.3",
    "babel-plugin-transform-runtime": "^6.23.0",
    "babel-preset-env": "^1.7.0",
    "babel-preset-stage-2": "^6.24.1",
    "chance": "^1.0.13",
    "eslint": "^4.18.2",
    "eslint-config-standard": "^5.1.0",
    "eslint-plugin-promise": "^1.1.0",
    "eslint-plugin-standard": "^1.3.2",
    "jest": "^22.3.0"
  },
  "engines": {
    "node": ">=4.0.0"
  }
}


// 步骤二：
/**
 * @file Just a super-simple wrapper for determining whether to load the original ES6 version
 * of the code or the ES5 version at runtime.
 * @author Joshua Bemenderfer <tribex10@gmail.com>
 */

// Is there a better way to check versions? Haven't really looked into it.
if (+process.versions.node.split('.')[0] >= 8) {
  // Native (Node 8+) ES6. (Requires async / await.)
  module.exports = require('./es6/index.js')
} else {
  // Transpiled through babel to target Node 4+.
  module.exports = require('./es5-autogenerated/index.js')
}

// 步骤三：
// ./es6/index.js
// 引入express服务器
const Server = require('./server')
const PortFinder = require('portfinder')

const PACKAGE_NAME = '[Prerenderer]'

const OPTION_SCHEMA = {
  staticDir: {
    type: String,
    required: true
  },
  indexPath: {
    type: String,
    required: false
  }
}

function validateOptionsSchema (schema, options, parent) {
  var errors = []

  Object.keys(schema).forEach(key => {
    // Required options
    if (schema[key].required && !options[key]) {
      errors.push(`"${parent || ''}${key}" option is required!`)
      return
    // Options with default values or potential children.
    } else if (!options[key] && (schema[key].default || schema[key].children)) {
      options[key] = schema[key].default != null ? schema[key].default : {}
      // Non-required empty options.
    } else if (!options[key]) return

    // Array-type options
    if (Array.isArray(schema[key].type) && schema[key].type.indexOf(options[key].constructor) === -1) {
      console.log(schema[key].type.indexOf(options[key].constructor))
      errors.push(`"${parent || ''}${key}" option must be a ${schema[key].type.map(t => t.name).join(' or ')}!`)
      // Single-type options.
    } else if (!Array.isArray(schema[key].type) && options[key].constructor !== schema[key].type) {
      errors.push(`"${parent || ''}${key}" option must be a ${schema[key].type.name}!`)
      return
    }

    if (schema[key].children) {
      errors.push(...validateOptionsSchema(schema[key].children, options[key], key))
      return
    }
  })

  errors.forEach(function (error) {
    console.error(`${PACKAGE_NAME} ${error}`)
  })

  return errors
}

class Prerenderer {
  constructor (options) {
    this._options = options || {}

    this._server = new Server(this)
    this._renderer = options.renderer

    if (this._renderer && this._renderer.preServer) this._renderer.preServer(this)

    if (!this._options) throw new Error(`${PACKAGE_NAME} Options must be defined!`)

    if (!this._options.renderer) {
      throw new Error(`${PACKAGE_NAME} No renderer was passed to prerenderer.
If you are not sure wihch renderer to use, see the documentation at https://github.com/tribex/prerenderer.`)
    }

    if (!this._options.server) this._options.server = {}

    const optionValidationErrors = validateOptionsSchema(OPTION_SCHEMA, this._options)

    if (optionValidationErrors.length !== 0) throw new Error(`${PACKAGE_NAME} Options are invalid. Unable to prerender!`)
  }

  async initialize () {
    // Initialization is separate from construction because science? (Ideally to initialize the server and renderer separately.)
    this._options.server.port = this._options.server.port || await PortFinder.getPortPromise() || 13010
    await this._server.initialize()
    await this._renderer.initialize()

    return Promise.resolve()
  }

  destroy () {
    this._renderer.destroy()
    this._server.destroy()
  }

  getServer () {
    return this._server
  }

  getRenderer () {
    return this._renderer
  }

  getOptions () {
    return this._options
  }

  modifyServer (server, stage) {
    if (this._renderer.modifyServer) this._renderer.modifyServer(this, server, stage)
  }

  renderRoutes (routes) {
    return this._renderer.renderRoutes(routes, this)
    // Handle non-ASCII or invalid URL characters in routes by normalizing them back to unicode.
    // Some browser environments may change unicode or special characters in routes to percent encodings.
    // We need to convert them back for saving in the filesystem.
    .then(renderedRoutes => {
      renderedRoutes.forEach(rendered => {
        rendered.route = decodeURIComponent(rendered.route)
      })

      return renderedRoutes
    })
  }
}

module.exports = Prerenderer

// 步骤4：
// ./es6/server.js
const express = require('express')
const proxy = require('http-proxy-middleware')
const path = require('path')

class Server {
  constructor (Prerenderer) {
    this._prerenderer = Prerenderer
    this._options = Prerenderer.getOptions()
    this._expressServer = express()
    this._nativeServer = null
  }

  initialize () {
    const server = this._expressServer

    // 支持自定义服务器
    if (this._options.server && this._options.server.before) {
      this._options.server.before(server)
    }

    this._prerenderer.modifyServer(this, 'pre-static')

    // 设置静态文件服务器
    server.get('*', express.static(this._options.staticDir, {
      // 其实就是如何处理逗号.
      // https://expressjs.com/zh-cn/api.html#dotfiles
      // “allow” - No special treatment for dotfiles.
      // “deny” - Deny a request for a dotfile, respond with 403, then call next().
      // “ignore” - Act as if the dotfile does not exist, respond with 404, then call next().
      dotfiles: 'allow'
    }))

    this._prerenderer.modifyServer(this, 'post-static')

    this._prerenderer.modifyServer(this, 'pre-fallback')

    // 用户是否传入了自己的proxy配置
    if (this._options.server && this._options.server.proxy) {
      for (let proxyPath of Object.keys(this._options.server.proxy)) {
        server.use(proxyPath, proxy(this._options.server.proxy[proxyPath]))
      }
    }

    server.get('*', (req, res) => {
      // 如果路径不存在，这里返回index.html
      res.sendFile(this._options.indexPath ? this._options.indexPath : path.join(this._options.staticDir, 'index.html'))
    })

    this._prerenderer.modifyServer(this, 'post-fallback')

    return new Promise((resolve, reject) => {
      this._nativeServer = server.listen(this._options.server.port, () => {
        resolve()
      })
    })
  }

  destroy () {
    this._nativeServer.close()
  }
}

module.exports = Server


```

