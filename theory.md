## 总结

1. 根据node版本选择对应的渲染模块
2. 利用express起服务，支持自定义proxy，设置静态文件服务器，拦截请求，如果没有找到则返回index.html
3. 

- @prerenderer/prerenderer
- @prerenderer/renderer-puppeteer

## @prerenderer/prerenderer

```js
// 步骤一：@prerenderer/prerenderer的package.json
{
  "name": "@prerenderer/prerenderer",
  "version": "0.7.2",
  "description": "Fast, flexible, framework-agnostic prerendering for sites and SPAs.",
  "license": "MIT",
  "main": "index.js", // @prerenderer/prerenderer文件的主入口
  "scripts": {
    "build": "babel es6 --out-dir es5-autogenerated",
    "test": "jest ./test --silent --runInBand",
    "test:jsdom": "jest ./test/**/*.jsdom.test.js --silent --runInBand",
    "test:puppeteer": "jest ./test/**/*.puppeteer.test.js --silent --runInBand",
    "test:logs": "jest ./test --runInBand",
    "test:logs:jsdom": "jest ./test/**/*.jsdom.test.js --runInBand",
    "test:logs:puppeteer": "jest ./test/**/*.puppeteer.test.js --runInBand",
    "prepublishOnly": "npm run build"
  },
  "jest": {
    "transform": {},
    "testURL": "http://localhost/"
  },
  "files": [
    "es6/*",
    "es5-autogenerated/*"
  ],
  "keywords": [
    "prerender",
    "prerenderer",
    "spa",
    "ssr",
    "serverside-rendering",
    "chrome-rdp"
  ],
  "author": {
    "name": "Joshua Bemenderfer",
    "email": "tribex10@gmail.com",
    "url": "https://joshderf.com/"
  },
  "contributors": [
    {
      "name": "Joshua Bemenderfer",
      "email": "tribex10@gmail.com",
      "url": "https://joshderf.com/"
    }
  ],
  "repository": "Tribex/prerenderer",
  "bugs": {
    "url": "https://github.com/Tribex/prerenderer/issues",
    "email": "tribex10@gmail.com"
  },
  "dependencies": {
    "express": "^4.16.2", // express服务器
    "http-proxy-middleware": "^0.18.0", // 代理转发
    "portfinder": "^1.0.13" // 端口查找
  },
  "devDependencies": {
    "babel-cli": "^6.26.0",
    "babel-eslint": "^7.2.3",
    "babel-plugin-transform-runtime": "^6.23.0",
    "babel-preset-env": "^1.7.0",
    "babel-preset-stage-2": "^6.24.1",
    "chance": "^1.0.13",
    "eslint": "^4.18.2",
    "eslint-config-standard": "^5.1.0",
    "eslint-plugin-promise": "^1.1.0",
    "eslint-plugin-standard": "^1.3.2",
    "jest": "^22.3.0"
  },
  "engines": {
    "node": ">=4.0.0"
  }
}


// 步骤二：@prerenderer/prerenderer的入口
/**
 * @file Just a super-simple wrapper for determining whether to load the original ES6 version
 * of the code or the ES5 version at runtime.
 * @author Joshua Bemenderfer <tribex10@gmail.com>
 */

// Is there a better way to check versions? Haven't really looked into it.
if (+process.versions.node.split('.')[0] >= 8) {
  // Native (Node 8+) ES6. (Requires async / await.)
  module.exports = require('./es6/index.js')
} else {
  // Transpiled through babel to target Node 4+.
  module.exports = require('./es5-autogenerated/index.js')
}

// 步骤三：@prerenderer/prerenderer的./es6/index.js
// ./es6/index.js
// 主要是：引入express服务器、校验配置、定义一些方法
const Server = require('./server')
const PortFinder = require('portfinder')

const PACKAGE_NAME = '[Prerenderer]'

const OPTION_SCHEMA = {
  staticDir: {
    type: String,
    required: true
  },
  indexPath: {
    type: String,
    required: false
  }
}

function validateOptionsSchema (schema, options, parent) {
  var errors = []

  Object.keys(schema).forEach(key => {
    // Required options
    if (schema[key].required && !options[key]) {
      errors.push(`"${parent || ''}${key}" option is required!`)
      return
    // Options with default values or potential children.
    } else if (!options[key] && (schema[key].default || schema[key].children)) {
      options[key] = schema[key].default != null ? schema[key].default : {}
      // Non-required empty options.
    } else if (!options[key]) return

    // Array-type options
    if (Array.isArray(schema[key].type) && schema[key].type.indexOf(options[key].constructor) === -1) {
      console.log(schema[key].type.indexOf(options[key].constructor))
      errors.push(`"${parent || ''}${key}" option must be a ${schema[key].type.map(t => t.name).join(' or ')}!`)
      // Single-type options.
    } else if (!Array.isArray(schema[key].type) && options[key].constructor !== schema[key].type) {
      errors.push(`"${parent || ''}${key}" option must be a ${schema[key].type.name}!`)
      return
    }

    if (schema[key].children) {
      errors.push(...validateOptionsSchema(schema[key].children, options[key], key))
      return
    }
  })

  errors.forEach(function (error) {
    console.error(`${PACKAGE_NAME} ${error}`)
  })

  return errors
}

class Prerenderer {
  constructor (options) {
    this._options = options || {}

    this._server = new Server(this)
    this._renderer = options.renderer

    if (this._renderer && this._renderer.preServer) this._renderer.preServer(this)

    if (!this._options) throw new Error(`${PACKAGE_NAME} Options must be defined!`)

    if (!this._options.renderer) {
      throw new Error(`${PACKAGE_NAME} No renderer was passed to prerenderer.
If you are not sure wihch renderer to use, see the documentation at https://github.com/tribex/prerenderer.`)
    }

    if (!this._options.server) this._options.server = {}

    const optionValidationErrors = validateOptionsSchema(OPTION_SCHEMA, this._options)

    if (optionValidationErrors.length !== 0) throw new Error(`${PACKAGE_NAME} Options are invalid. Unable to prerender!`)
  }

  async initialize () {
    // Initialization is separate from construction because science? (Ideally to initialize the server and renderer separately.)
    this._options.server.port = this._options.server.port || await PortFinder.getPortPromise() || 13010
    await this._server.initialize()
    await this._renderer.initialize()

    return Promise.resolve()
  }

  destroy () {
    this._renderer.destroy()
    this._server.destroy()
  }

  getServer () {
    return this._server
  }

  getRenderer () {
    return this._renderer
  }

  getOptions () {
    return this._options
  }

  modifyServer (server, stage) {
    if (this._renderer.modifyServer) this._renderer.modifyServer(this, server, stage)
  }

  renderRoutes (routes) {
    return this._renderer.renderRoutes(routes, this)
    // Handle non-ASCII or invalid URL characters in routes by normalizing them back to unicode.
    // Some browser environments may change unicode or special characters in routes to percent encodings.
    // We need to convert them back for saving in the filesystem.
    .then(renderedRoutes => {
      renderedRoutes.forEach(rendered => {
        rendered.route = decodeURIComponent(rendered.route)
      })

      return renderedRoutes
    })
  }
}

module.exports = Prerenderer

// 步骤4：@prerenderer/prerenderer的./es6/server.js
// ./es6/server.js
// 主要是：定义express服务器，静态服务器、重定向等。
const express = require('express')
const proxy = require('http-proxy-middleware')
const path = require('path')

class Server {
  constructor (Prerenderer) {
    this._prerenderer = Prerenderer
    this._options = Prerenderer.getOptions()
    this._expressServer = express()
    this._nativeServer = null
  }

  initialize () {
    const server = this._expressServer

    // 支持自定义服务器
    if (this._options.server && this._options.server.before) {
      this._options.server.before(server)
    }

    this._prerenderer.modifyServer(this, 'pre-static')

    // 设置静态文件服务器
    server.get('*', express.static(this._options.staticDir, {
      // 其实就是如何处理逗号.
      // https://expressjs.com/zh-cn/api.html#dotfiles
      // “allow” - No special treatment for dotfiles.
      // “deny” - Deny a request for a dotfile, respond with 403, then call next().
      // “ignore” - Act as if the dotfile does not exist, respond with 404, then call next().
      dotfiles: 'allow'
    }))

    this._prerenderer.modifyServer(this, 'post-static')

    this._prerenderer.modifyServer(this, 'pre-fallback')

    // 用户是否传入了自己的proxy配置
    if (this._options.server && this._options.server.proxy) {
      for (let proxyPath of Object.keys(this._options.server.proxy)) {
        server.use(proxyPath, proxy(this._options.server.proxy[proxyPath]))
      }
    }

    server.get('*', (req, res) => {
      // 如果路径不存在，这里返回index.html
      res.sendFile(this._options.indexPath ? this._options.indexPath : path.join(this._options.staticDir, 'index.html'))
    })

    this._prerenderer.modifyServer(this, 'post-fallback')

    return new Promise((resolve, reject) => {
      this._nativeServer = server.listen(this._options.server.port, () => {
        resolve()
      })
    })
  }

  destroy () {
    this._nativeServer.close()
  }
}

module.exports = Server
```


## @prerenderer/renderer-puppeteer

操作无头浏览器的库，分两个，一个比较轻量即jsdom，一个是puppeteer比较大而全；

- renderer-jsdom
- renderer-puppeteer

下面先分析renderer-puppeteer

```js
// 步骤一：依然是根据package.json里的main字段确定入口
// Is there a better way to check versions? Haven't really looked into it.
if (+process.versions.node.split('.')[0] >= 8) {
  // Native (Node 8+) ES6. (Requires async / await.)
  module.exports = require('./es6/renderer.js')
} else {
  // Transpiled through babel to target Node 4+.
  module.exports = require('./es5-autogenerated/renderer.js')
}

// 步骤二：查看./es6/renderer.js
// 生成页面的屏幕截图或 pdf
// 自动化提交表单、模拟键盘输入、自动化单元测试等
// 网站性能分析：可以抓取并跟踪网站的执行时间轴，帮助分析效率问题
// 抓取网页内容，也就是我们常说的爬虫

// 之前的promise.all等都是全部返回才结束，而这个可以控制每次返回的数量
// 进而可以减少同时并发太多
// https://www.npmjs.com/package/promise-limit
const promiseLimit = require('promise-limit')
// 终于找到根文件了
const puppeteer = require('puppeteer')

const waitForRender = function (options) {
  options = options || {}

  return new Promise((resolve, reject) => {
    // Render when an event fires on the document.
    if (options.renderAfterDocumentEvent) {
      if (window['__PRERENDER_STATUS'] && window['__PRERENDER_STATUS'].__DOCUMENT_EVENT_RESOLVED) resolve()
      // 这里就是指定页面什么事件触发渲染，因为用document绑定的事件，因此像load事件就不行了。。。但也很少使用load事件
      document.addEventListener(options.renderAfterDocumentEvent, () => resolve())

    // Render after a certain number of milliseconds.
    } else if (options.renderAfterTime) {
      setTimeout(() => resolve(), options.renderAfterTime)

    // Default: Render immediately after page content loads.
    } else {
      resolve()
    }
  })
}

class PuppeteerRenderer {
  constructor (rendererOptions) {
    this._puppeteer = null
    this._rendererOptions = rendererOptions || {}

    if (this._rendererOptions.maxConcurrentRoutes == null) this._rendererOptions.maxConcurrentRoutes = 0

    // 如果没有配置，则默认添加__PRERENDER_INJECTED属性
    if (this._rendererOptions.inject && !this._rendererOptions.injectProperty) {
      this._rendererOptions.injectProperty = '__PRERENDER_INJECTED'
    }
  }

  async initialize () {
    try {
      // 判断平台
      // Workaround for Linux SUID Sandbox issues.
      if (process.platform === 'linux') {
        if (!this._rendererOptions.args) this._rendererOptions.args = []

        if (this._rendererOptions.args.indexOf('--no-sandbox') === -1) {
          this._rendererOptions.args.push('--no-sandbox')
          this._rendererOptions.args.push('--disable-setuid-sandbox')
        }
      }

      // 启动浏览器
      this._puppeteer = await puppeteer.launch(this._rendererOptions)
    } catch (e) {
      console.error(e)
      console.error('[Prerenderer - PuppeteerRenderer] Unable to start Puppeteer')
      // Re-throw the error so it can be handled further up the chain. Good idea or not?
      throw e
    }

    return this._puppeteer
  }

  async handleRequestInterception (page, baseURL) {
    // 其实就是激活请求拦截，激活后就可以以同步代码形式来操作请求了，是暂停还是取消等，都可以控制了
    // https://pptr.dev/#?product=Puppeteer&version=v7.1.0&show=api-pagesetrequestinterceptionvalue
    await page.setRequestInterception(true)

    page.on('request', req => {
      // Skip third party requests if needed.
      if (this._rendererOptions.skipThirdPartyRequests) {
        // 有白名单，怎么还需要判断这里？第三方的请求，肯定不满足条件
        if (!req.url().startsWith(baseURL)) {
          req.abort()
          return
        }
      }

      req.continue()
    })
  }

  async renderRoutes (routes, Prerenderer) {
    const rootOptions = Prerenderer.getOptions()
    const options = this._rendererOptions

    // 限流控制渲染的数量
    const limiter = promiseLimit(this._rendererOptions.maxConcurrentRoutes)

    const pagePromises = Promise.all(
      routes.map(
        (route, index) => limiter(
          async () => {
            // 开启一个页面
            const page = await this._puppeteer.newPage()

            // 注册console
            if (options.consoleHandler) {
              page.on('console', message => options.consoleHandler(route, message))
            }

            // 是否需要像window上注入一些全局属性，值就是JSON.stringify(options.inject)
            if (options.inject) {
              // https://pptr.dev/#?product=Puppeteer&version=v7.1.0&show=api-pageevaluateonnewdocumentpagefunction-args
              // 切换新页签或其他情况下会触发，而且触发的时机是after the document was created but before any of its scripts were run
              await page.evaluateOnNewDocument(`(function () { window['${options.injectProperty}'] = ${JSON.stringify(options.inject)}; })();`)
            }

            // 默认是localhost
            const baseURL = `http://localhost:${rootOptions.server.port}`

            // Allow setting viewport widths and such.
            if (options.viewport) await page.setViewport(options.viewport)

            // page就是当前浏览器tab的实例，然后访问首页
            await this.handleRequestInterception(page, baseURL)

            // 防止document的事件在我们添加的事件之前触发。。
            // Hack just in-case the document event fires before our main listener is added.
            if (options.renderAfterDocumentEvent) {
              page.evaluateOnNewDocument(function (options) {
                window['__PRERENDER_STATUS'] = {}
                document.addEventListener(options.renderAfterDocumentEvent, () => {
                  window['__PRERENDER_STATUS'].__DOCUMENT_EVENT_RESOLVED = true
                })
              }, this._rendererOptions)
            }
            
            // waitUntil代表什么时候才认为导航加载成功。其实就是一个标准，如果发现满足这些条件了，我就认为你页面加载好了
            // load: window.onload事件被触发时候完成导航,某些情况下它根本不会发生。
            // domcontentloaded: Domcontentloaded事件触发时候认为导航成功
            // networkidle0: 在 500ms 内没有网络连接时就算成功(全部的request结束),才认为导航结束
            // networkidle2: 500ms 内有不超过 2 个网络连接时就算成功(还有两个以下的request),就认为导航完成。

            const navigationOptions = (options.navigationOptions) ? { waituntil: 'networkidle0', ...options.navigationOptions } : { waituntil: 'networkidle0' };
            await page.goto(`${baseURL}${route}`, navigationOptions);

            // 还可以指定一些具体的某些元素是否存在
            // Wait for some specific element exists
            const { renderAfterElementExists } = this._rendererOptions
            if (renderAfterElementExists && typeof renderAfterElementExists === 'string') {
              // 暂时没说是靠哪种方式拿到了，但对于chrome，此事应该很简单
              // https://pptr.dev/#?product=Puppeteer&version=v7.1.0&show=api-pagewaitforselectorselector-options
              await page.waitForSelector(renderAfterElementExists)
            }
            // Once this completes, it's safe to capture the page contents.
            await page.evaluate(waitForRender, this._rendererOptions)

            const result = {
              originalRoute: route,
              route: await page.evaluate('window.location.pathname'),
              html: await page.content() // 这就拿到了最终的html
            }

            await page.close()
            return result
          }
        )
      )
    )

    return pagePromises
  }

  destroy () {
    if(this._puppeteer) {
      try {
        this._puppeteer.close()
      } catch (e) {
        console.error(e)
        console.error('[Prerenderer - PuppeteerRenderer] Unable to close Puppeteer')
		  
        throw e
      }
    }
  }
}

module.exports = PuppeteerRenderer
```


看完prerenderer-puppeteer的封装，再看jsdom的，就少了很多

```js
const JSDOM = require('jsdom/lib/old-api.js').jsdom
const serializeDocument = require('jsdom/lib/old-api.js').serializeDocument
const promiseLimit = require('promise-limit')

const shim = function (window) {
  window.SVGElement = window.HTMLElement
  window.localStorage = window.sessionStorage = {

    getItem: function (key) {
      return this[key]
    },

    setItem: function (key, value) {
      this[key] = value
    }
  }
}

const getPageContents = function (window, options, originalRoute) {
  options = options || {}

  return new Promise((resolve, reject) => {
    let int

    function captureDocument () {
      const result = {
        originalRoute: originalRoute,
        route: originalRoute,
        html: serializeDocument(window.document)
      }

      if (int != null) {
        clearInterval(int)
      }

      window.close()
      return result
    }

    // CAPTURE WHEN AN EVENT FIRES ON THE DOCUMENT
    if (options.renderAfterDocumentEvent) {
      window.document.addEventListener(options.renderAfterDocumentEvent, () => resolve(captureDocument()))

    // CAPTURE ONCE A SPECIFC ELEMENT EXISTS
    } else if (options.renderAfterElementExists) {
      let doc = window.document
      int = setInterval(() => {
        // 这是就使用doc.querySelector来获取对应的元素了
        if (doc.querySelector(options.renderAfterElementExists)) resolve(captureDocument())
      }, 100)

    // CAPTURE AFTER A NUMBER OF MILLISECONDS
    } else if (options.renderAfterTime) {
      setTimeout(() => resolve(captureDocument()), options.renderAfterTime)

    // DEFAULT: RUN IMMEDIATELY
    } else {
      resolve(captureDocument())
    }
  })
}

class JSDOMRenderer {
  constructor (rendererOptions) {
    this._rendererOptions = rendererOptions || {}

    if (this._rendererOptions.maxConcurrentRoutes == null) this._rendererOptions.maxConcurrentRoutes = 0

    if (this._rendererOptions.inject && !this._rendererOptions.injectProperty) {
      this._rendererOptions.injectProperty = '__PRERENDER_INJECTED'
    }
  }

  async initialize () {
    // NOOP
    return Promise.resolve()
  }

  async renderRoutes (routes, Prerenderer) {
    const rootOptions = Prerenderer.getOptions()

    const limiter = promiseLimit(this._rendererOptions.maxConcurrentRoutes)

    const results = Promise.all(routes.map(route => limiter(() => {
      return new Promise((resolve, reject) => {
        JSDOM.env({
          url: `http://127.0.0.1:${rootOptions.server.port}${route}`,
          features: {
            FetchExternalResources: ['script'],
            ProcessExternalResources: ['script'],
            SkipExternalResources: false
          },
          created: (err, window) => {
            if (err) return reject(err)
            // Injection / shimming must happen before we resolve with the window,
            // otherwise the page will finish loading before the injection happens.
            if (this._rendererOptions.inject) {
              window[this._rendererOptions.injectProperty] = this._rendererOptions.inject
            }

            window.addEventListener('error', function (event) {
              console.error(event.error)
            })

            shim(window)

            resolve(window)
          }
        })
      })
      .then(window => {
        return getPageContents(window, this._rendererOptions, route)
      })
    })))
    .catch(e => {
      console.error(e)
      return Promise.reject(e)
    })

    return results
  }

  destroy () {
    // NOOP
  }
}

module.exports = JSDOMRenderer
```
